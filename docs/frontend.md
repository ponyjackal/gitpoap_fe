# Frontend

The goal of this document is to enable the team to work faster, more effectively, with a great degree of standardization, & more autonomy in all related repos at GitPOAP. This is a living document that will change over time.

That said, we'll start by offering a set of best practices and answers to general engineering related questions that commonly arise.


## Table of Contents
- [Best Practices](#best-practices)
  - [Code Formatting](#code-formatting)
  - [Code Style](#code-style)
  - [Commits](#commits)
  - [Documentation](#documentation)
  - [Incrementalism](#incrementalism)
  - [Linting](#linting)
  - [Pull Requests](#pull-requests)
  - [Typescript](#typescript)
  - [Type Safety](#type-safety)
- [FAQ](#faq)
  - [How do you connect to the production DB client?](#how-do-you-connect-to-the-production-db-client)
  - [How do you generate GraphQL types and React hooks on the frontend?](#how-do-you-generate-graphql-types-and-react-hooks-on-the-frontend)
  - [How to set up AWS for use in the dev environment?](#how-to-set-up-aws-for-use-in-the-dev-environment)
  - [How to configure AWS IAM permissions?](#how-to-configure-aws-iam-permissions)
  - [What is the purpose of redeem codes?](#what-is-the-purpose-of-redeem-codes)
  - [How to run the backend server?](#how-to-run-the-backend-server)
  - [How to run the frontend server?](#how-to-run-the-frontend-server)
  - [How do migrations work?](#how-do-migrations-work)


## Best Practices

### Code Formatting
All code should be formatted by prettier in the `gitpoap-fe` & `gitpoap-backend` repos. In general, the larger repos have pre-commit hooks enabled by `husky` that check for any code formatting violations, and prevent committing as a result. The code formatting standard that we use is the relatively uncontroversial, but highly opinionated `prettier/prettier` rule set, in addition to a small number of custom rules defined by the team in various `.prettierrc` files at the root of various repositories. Please refrain from adding your own rules here without first gaining consensus from the rest of the team.


### Code Style
All code should be written in a consistent style - this is an important part of the team's culture that result in the reduction of the amount of work needed to maintain the codebase & also vastly minimizes the amount of time & attention wasted on debating code style.

1. Write appropriate comments & with the style `/* comment body */`.

2. Use `const` instead of `let` or `var` wherever possible.

3. Name boolean variables as a question - `isSomething` instead of `something`.

4. Name variables properly - they should be self-documenting.

5. Name files properly - they should be self-documenting

6. Keep the file structure as flat as possible - nest only when essential.

7. Use the null coalescing operator `??` instead of `||` and `&&` operators whenever possible.

8. Minimize the use of `any` and `as` for type assertions. Use `unknown` and type guards instead.

9. Use line breaks to make code more readable.

10. For frontend code, use common shared elements as frequently as possible.

11. Use a validation library like `zod` instead of writing your own.

12. *Never* use `// @ts-ignore` in production code. Let TypeScript do its job.

13. Break up large components into smaller ones.

14. Prioritize the use of `graphql` and autogenerated code & types.

15. Use `async`/`await` over raw promises (`.then` etc).

### Commits
Similar to how PRs should be sized & described appropriately, commits should be split up in a way that makes sense for future readers. Additionally, we suggest using semantic commit messages. Semantic commit messages have a number of benefits - namely, they make it easier for readers to immediately grasp the essence of the commit, & equally importantly they force the developer to commit code in chunks that can be described in a very short sentence. Refer to the [Conventional Commits Guide](https://www.conventionalcommits.org/en/v1.0.0/) for more information.

### Documentation
As a practice, writing high-quality documentation heavily contributes to setting an organization & team's processes, culture, & direction, and increases the effectiveness of all team members.

#### Process Documentation
Effective, repeatable, & standardized processes or ways of doing things are codified through good documentation. This documentation serves as a reference for team members to help them use their time more effectively & learn best practices in an efficient way. As a meta thought, the document you're reading right now is an expression of this sentiment & hopefully you take something useful away from it.

#### Technical Documentation
For larger scale projects & changes, writing proposals and technical design documents is beneficial - these documents are easy to share, review, modify, and collectively come to consensus on how to approach an initiative. These documents at minimum should contain a brief summary of the initiative & proposed approach, but can also contain information on the research performed, assessed options, challenges, references, and any other relevant information.

#### Tickets
In general, people wish to understand the high-level context & purpose of anything they're doing. Unsurprisingly, engineers are not an exception. As a result, tickets should contain *both* a summary of the work involved, but also a 'purpose' section describing how the ticket fits into larger-scale initiatives & objectives. The goal is to make working on these tickets more meaningful.

### Incrementalism
Since GitPOAP is a small startup, engineers have a wide range of responsibilities & power to shape the future of the codebase. As a result, engineers should feel empowered & are *highly encouraged* to fix and improve things as they see them in addition to proposing larger-scale changes that make sense in the context of the company & team's collective goals.

### Linting
We are using ESLint using the community standard settings for `react` and `typescript`. Please take the time to remove any errors in code that you happen to be working on if you notice any present, and avoid adding new errors or warnings.

### Pull Requests
Code should generally be reviewed by one or multiple members of the team prior to being merged into `main`. This is to ensure that code is well-written, well-formatted, well-tested, & aligns with the team's style & preferences.

When creating PRs, ensure that the title is accurate, a detailed and concise description is provided, & that the PR contains tests (if applicable) that verify the functionality of the code.

PRs should be sized appropriately to ensure that the team can effectively review the code & things aren't missed due to the size of the PR.

### TypeScript
All code related to frontend applications, and the vast majority of code in general at GitPOAP should be written in TypeScript with `strict-mode` enabled & should use meaningful type declarations.


### Type Safety
We are leveraging TypeScript for type safety in our repository. It goes without saying that static typing provides several benefits for developers and engineering organizations in general - the important benefits are enumerated here:

1. No more `undefined is not a function`, `cannot access property x of undefined`. When we write code without being forced to think about the types, it's easy to improperly infer and assume what the parameters & return types of a function actually are.

2. Improved refactorability & scalability. TypeScript reduces the time and mental focus required for refactoring, while increasing confidence & improving the quality of refactors. It reduces a lot of the mental overhead associated with remembering the interfaces & shapes of various functions & objects. As we make changes to the code, TypeScript will conveniently notify the developer of changes that fail typechecking and break parts of the application.

3. Documentation. TypeScript enables self-documenting code and allows engineers to click through function calls, variables, and types, to quickly understand how things work.

For us to maximally benefit from the use of TypeScript, it's important that we let TypeScript do its job, refrain from disabling type-checking via `any`, and minimize the use of typecasting via `as` or `<>`.

At the same time, there are instances where the type of an object is not known & the temptation to use `any` arises. An example of this is a JSON response from a third party API - here we can assume, but not know definitively what the structure of the response is unless provided to us via an SDK. For this situation, TypeScript has the keyword `unknown`. While `unknown` is similar to `any`, it has one large difference. Namely, instead of implying that a value can be of `any` type and exiting typechecking, `unknown` implies that the type could be anything, but is not known & must be asserted or derived a priori via type narrowing or type guards (`instanceof`, `typeof`).


## FAQ

### How do you connect to the production DB client?
To connect to the production DB client, ask a senior member of the team for the `.pem` file that contains the ssh private key needed to access the box. Then, run the following command in a separate terminal pane.

```bash
ssh -i .ssh/db-client-key-pair.pem ubuntu@ec2-18-220-67-80.us-east-2.compute.amazonaws.com
```

<br />

### How do you generate GraphQL types and React hooks on the frontend?
To run the graphql code generation tool, run `yarn gql:generate` - this generates code based on the schema found at `api.gitpoap.io/graphql` that is based on the `main` branch.

To run the tool for development purposes, run `yarn gql:generate-dev`. Ensure that `gitpoap-backend` is located in the same parent directory as `gitpoap-fe`. This generates code based on the query definitions found in `../gitpoap-fe/operations.gql` & validates the queries against the schema found at `../gitpoap-backend/schema.graphql`.

For more information, refer to the doc [gql-typegen.md](gql-typegen.md).

<br />

### How to set up AWS for use in the dev environment?
To connect to AWS in the dev environment, the SDK requires a set of credentials for the dev `docker-agent` identity entity on AWS. In order for the SDK to access this information, the credentials must be defined in a specific location on your machine.

In order to get AWS connectivity working in the dev environment, first install the [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html). Once you've installed it, create a folder named `.aws` in your home directory, `~/.aws`. Next, create a file named `~/.aws/config` and add `[docker-agent]` on the first line. Next, add a file named `~/.aws/credentials` and add the following to it:
```
[docker-agent]
  aws_access_key_id = AKIAXNRJHAN53HRZVSO2
  aws_secret_access_key = <Ask for this access key or find it on AWS>
```

Upon doing this, the AWS SDK in the dev environment should automatically pick up the credentials and connect to AWS resources.

<br />

### How to configure AWS IAM permissions?
AWS IAM is composed of a multiple different entities ~ identities, permissions, policies, and roles. A policy is a set of permissions, and a role is a set of policies. Roles are assignable to identities. Examples of specific identity entities would be specific developer identities for engineers that represent people, while there are also identity entities for environments and services such as the `gitpoap-backend`.

The IAM role for the `gitpoap-backend` server is `gitpoap-backend-server-task-definition`. This role is attached to specific `ECS` (Elastic Container Service) task definitions defined in code - the backend server is defined & deployed via an `ECS` task definition.

For example, in order to grant the backend permission to access `S3`, find an already created policy with the appropriate permissions, find an appropriate policy & add the desired permissions to it, or create a new policy and add the desired permissions to it. Next, add this policy to the `gitpoap-backend-server-task-definition` role. In this case, the `AmazonS3FullAccess` policy (AWS managed) is added to the `gitpoap-backend-server-task-definition` role & the backend now has permission to access all of `S3`.

<br />

### What is the purpose of redeem codes?
Redeem codes are a key component of workflow associated with using the POAP API & related services. A redeem code is a 6-char random string that is associated with a particular POAP `event_id` & are issued during the initial creation of a POAP event. The total amount of remaining valid redeem codes can be extinguished, resulting in the need to request additional codes on a discretionary basis later in time.

When a user attempts to mint a new POAP, either they, or the application they are using must provide a valid redeem code for that specific POAP as specified by an `event_id`. Ostensibly, the purpose of a redeem code is to add a line of defense against POAP farming activities.

<br />

### How to run the backend server?
To start an instance of the server found in `gitpoap-backend`, first run `yarn docker:background` in one terminal pane, and then run `./.dockerfiles/run-server.sh` in separate terminal pane.

The first command `yarn docker:background` starts all services in the backend stack except for the server itself. For example, it starts a fake-poap-api, fake-poap-auth, postgres, prometheus, redis, & grafana.

The second command `./.dockerfiles/run-server.sh` runs the initial DB migrations, seed script, and then starts the server.

Since the seed script can't be run twice, run `yarn dev --level debug` instead of `run-server.sh` in order to start the backend after running `run-server.sh` that first initial time.

<br />

### How to run the frontend server?
To start an instance of the server found in `gitpoap-fe`, simply run `yarn` to install dependencies, and then run `yarn dev`. To test whether the frontend builds properly, run `yarn build` and inspect the output.

<br />

### How do migrations work?
Migrations are granular sets of database schema changes that track the evolution of the schema over time. A benefit of this practice is the ability to track schema changes over time within a version control system such as Git.

When setting up a development environment, migrations are applied sequentially to a new, untouched DB. Iterating through all the migrations associated with a database will result in a database with a schema that reflects its current form.

To create a new migration within the `gitpoap-backend` repository, do the following. First, make your schema change within `schema.prisma`, then run `npx prisma migrate dev --name <name>` to generate the migration file. Finally, commit these changes to a version control system.

To run all migrations, run `npx prisma migrate dev`.

For more information, refer to the prisma [documentation on migrations](https://www.prisma.io/docs/concepts/components/prisma-migrate).


